#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftDrive,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftDriveAssist, tmotorServoStandard, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightDriveAssist, tmotorServoStandard, openLoop, driveRight)
#pragma config(Motor,  port10,          rightDrive,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "robotc.h"

#define MOTOR_COUNT 10

#define STATE_LIFT_ON 1
#define STATE_

#define STATE_CLAW_OPEN 2

/**
 * State config:
 * 0 - 
 * For example, to access if the ball lift is on
 */
bool turretModuleState[5];

/**
 * State config:
 * 0 - Arm extension state (true if extended)
 * 1 - Claw activation state (true if open)
 * 
 * For example, to access if the arm is deployed:
 * bool armIsExtended = armModuleState[STATE_ARM_EXTENDED];
 */
bool armModuleState[4];

// Array to hold requested speed for the motors
int motorRequests[MOTOR_COUNT];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[MOTOR_COUNT];

void init()
{
    // TODO: Reset encoder and sensor values
}

void driveLeftSide(int tickCount)
{
    motorRequests[leftDrive] = tickCount;
    motorRequests[leftDriveAssist] = tickCount;
}

void driveRightSide(int tickCount)
{
    motorRequests[rightDrive] = tickCount;
    motorRequests[rightDriveAssist] = tickCount;
}

task handleMotorSlew()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
    {
        motorRequests[motorIndex] = 0;
        motorSlew[motorIndex] = 10;
    }

    // run task until stopped
    while (true)
    {
        // run loop for every motor
        for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
        {
            // So we don't keep accessing the internal storage
            motorTmp = motor[motorIndex];

            // Do we need to change the motor value ?
            if (motorTmp != motorRequests[motorIndex])
            {
                // increasing motor value
                if (motorRequests[motorIndex] > motorTmp)
                {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if (motorTmp > motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // decreasing motor value
                if (motorRequests[motorIndex] < motorTmp)
                {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if (motorTmp < motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // finally set motor
                motor[motorIndex] = motorTmp;
            }
        }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec(15);
    }
}

task handleDriving()
{
    while (true)
    {
        int leftJoystick = vexRT[Ch3];
        int rightJoystick = vexRT[Ch2];
        driveLeftSide(leftJoystick);
        driveRightSide(rightJoystick);
        wait1Msec(25);
    }
}

task handleTurretControl()
{
    while (true)
    {
        // TODO: Respond to button controls for turret
        wait1Msec(25);
    }
}

task handleArmControl()
{
    while (true)
    {
        // TODO: Respond to button controls for arm
        wait1Msec(25);
    }
}

/**
 * Runs initialization activites before competition start.
 */
void pre_auton()
{
    init();
}

task autonomous()
{
    // TODO: Use sensors to complete autonomous block
}

task userControl()
{
    init();
    startTask(handleMotorSlew);
    startTask(handleDriving);
    startTask(handleArmControl);
    startTask(handleTurretControl);
    while (true);
}

task main()
{
    startTask(userControl);
    while (true);
}
