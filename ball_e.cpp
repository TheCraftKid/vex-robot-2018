#pragma config(UserModel, "./foxbot_2_config.h")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "robotc.h"

#define MOTOR_COUNT 10
#define MAX_SPEED 127

#define ARM_STATIONARY 10

#define ARM_EXTENDING 20
#define ARM_RETRACTING 21

#define ARM_RAISING 30
#define ARM_LOWERING 31

/**
 * A set of variables that track the current position of the lifting arm.
 */
typedef struct RobotArmState
{
    /**
     * The distance from the origin measuring how far the arm has extended.
     */
    int x;

    /**
     * The distance from the arm's base height measuring how far the arm has raised.
     */
    int y;

    /**
     * Whether the arm is currently extending, retracting, or stationary.
     *
     * Use an equality operator with ARM_RAISING, ARM_LOWERING, or
     * ARM_STATIONARY to determine state.
     */
    short armLiftState;

    /**
     * Whether the arm is currently extending, retracting, or stationary.
     *
     * Use an equality operator with ARM_EXTENDING, ARM_RETRACTING, or
     * ARM_STATIONARY to determine state.
     */
    short armExtensionState;

    /**
     * True if the arm's claw is open.
     */
    bool clawActive;

} RobotArmState;

typedef struct RobotBaseState
{
    /**
     * True if the robot is using 4-wheel drive.
     */
    bool enhancedDriveEnabled;

    /**
     * True if two-controller input is active.
     *
     * This setting turns driver one's controller (primary) into the input source
     * for driving the base and operating the cap lift arm and turns driver two's
     * controller (partner) into the input source for the ball turret cannon.
     *
     * If this is false, player one's left joystick and buttons will control the
     * turret while the right joystick and buttons will control driving and cap
     * lift arm operation, respectively.
     */
    bool twoPlayerEnabled;

} RobotBaseState;

typedef struct RobotTurretState
{
    /**
     * True if the firing mechanism is in the process of launching a ball.
     */
    bool firing;

    /**
     * True if a ball should be launched.
     */
    bool preppedToFire;

} RobotTurretState;

typedef struct ArmModule
{
    RobotArmState armState;
} ArmModule;

typedef struct BaseModule
{
    RobotBaseState baseState;
} BaseModule;

typedef struct TurretModule
{
    RobotTurretState turretState;
} TurretModule;

ArmModule armModule = {
    {
        0,
        0,
        ARM_STATIONARY,
        ARM_STATIONARY,
        false,
    },
};

TurretModule turretModule = {
    {
        false,
        true,
    },
};

const short P2_OVERRIDE[5] = {
    0,
    0,
    0,
    0,
    0,
};

/**
 * The eight most recent button presses from the primray controller.
 *
 * Index 0 will always contain the most recent button input.
 */
short p1ButtonInputs[8];

/**
 * The eight most recent button presses from the partner controller.
 *
 * Index 0 will always contain the most recent button input.
 */
short p2ButtonInputs[8];

// Array to hold requested speed for the motors
int motorRequests[MOTOR_COUNT];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[MOTOR_COUNT];

RobotBaseState baseState = {
    false,
};

RobotArmState armState = {
    false,
    false,
};

void init()
{
    // TODO: Reset encoder and sensor values
}

/**
 * Checks if player 2 can override player 1's commands.
 * 
 * If done, player 2's inputs should be the only inputs (player 1's will be
 * ignored), and player 2 should have single player controls. 
 *
 * @return True if the last button inputs of player 2 match the override command
 */
bool checkOverrideCommmand()
{
    for (int i = 0; i < sizeof(P2_OVERRIDE); ++i)
    {
        if (P2_OVERRIDE[i] != p2ButtonInputs[i])
        {
            return false;
        }
    }
    return true;
}

void driveLeftSide(int tickCount)
{
    motorRequests[leftDrive] = tickCount;
    motorRequests[driveAssistLeft] = tickCount;
}

void driveRightSide(int tickCount)
{
    motorRequests[rightDrive] = tickCount;
    motorRequests[driveAssistRight] = tickCount;
}

task handleMotorSlew()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
    {
        motorRequests[motorIndex] = 0;
        motorSlew[motorIndex] = 10;
    }

    // run task until stopped
    while (true)
    {
        // run loop for every motor
        for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
        {
            // So we don't keep accessing the internal storage
            motorTmp = motor[motorIndex];

            // Do we need to change the motor value ?
            if (motorTmp != motorRequests[motorIndex])
            {
                // increasing motor value
                if (motorRequests[motorIndex] > motorTmp)
                {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if (motorTmp > motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // decreasing motor value
                if (motorRequests[motorIndex] < motorTmp)
                {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if (motorTmp < motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // finally set motor
                motor[motorIndex] = motorTmp;
            }
        }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec(15);
    }
}

task handleDriving()
{
    while (true)
    {
        int leftJoystick = vexRT[Ch3];
        int rightJoystick = vexRT[Ch2];
        driveLeftSide(leftJoystick);
        driveRightSide(rightJoystick);
        wait1Msec(25);
    }
}

task handleControllerInputs()
{
    // TODO: Intercept button presses, log them, and add them to p1ButtonInputs and p2ButtonInputs
}

void rotateTurret(int ticks)
{

}

void raiseTurret(int ticks)
{
    
}

/**
 * Activates the ball launcher for two seconds
 */
void fireTurret()
{
    if (!turretModule.turretState.preppedToFire || turretModule.turretState.firing)
    {
        // TODO: Log inability to fire
        return;
    }
    turretModule.turretState.firing = true; // Just to be safe
    motorRequests[ballLauncher] = MAX_SPEED;
    wait1Msec(2000);
    motorRequests[ballLauncher] = 0;
    turretModule.turretState.firing = false;
}

void resetTurret()
{
    // TODO: Check turret's potentiometer state, move to left or right based on distance from origin
}

task handleTurretControl()
{
    // TODO: Handle one-player mode
    while (true)
    {
        // TODO: Respond to button controls for turret
        if (vexRT[Btn8RXmtr2] == 1)
        {
            fireTurret();
        }
        if (vexRT[Btn8DXmtr2] == 1)
        {
            resetTurret();
        }

        int upness = vexRT[Ch3Xmtr2];
        int rotateness = vexRT[Ch1Xmtr2];
        raiseTurret(upness);
        wait1Msec(25);
    }
}

task handleArmControl()
{
    while (true)
    {
        // TODO: Respond to button controls for arm
        wait1Msec(25);
    }
}

/**
 * Runs initialization activites before competition start.
 */
void pre_auton()
{
    init();
}

task autonomous()
{
    // TODO: Use sensors to complete autonomous block
}

task userControl()
{
    init();
    startTask(handleMotorSlew);
    startTask(handleDriving);
    startTask(handleArmControl);
    startTask(handleTurretControl);
    while (true)
    {
        // TODO: Log current state using writeDebugStream
        wait1Msec(250);
    }
}

task main()
{
    startTask(userControl);
    while (true)
    {
        // Stall
    }
}
