#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1,  leftBumper,     sensorTouch)
#pragma config(Sensor, dgtl2,  rightBumper,    sensorTouch)
#pragma config(Sensor, dgtl3,  armBaseEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armClawEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  bottomLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl8,  bottomUpperLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl9,  topLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl10, upperLimitSwitch, sensorTouch)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftWheels,    tmotorVex269_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           armLowLeft,    tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           armLowRight,   tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           armHighLeft,   tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armHighRight,  tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port7,           winch,         tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           launcher,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           launcherLift,  tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          rightWheels,   tmotorVex269_HBridge, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "robotc.h"

#define ARM_RAISE_TICK_GOAL 100

#define MAX_SPEED 127

/**
 * Both arm components (low and high) are completely lowered.
 */
#define ARM_LOWERED 100

/**
 * The low arm component is being lowered, but the high isn't.
 */
#define ARM_LOWERING_LOW 101

/**
 * The high arm component is being lowered, but the low isn't.
 */
#define ARM_LOWERING_HIGH 102

/**
 * The low arm component is raised, but the high one isn't.
 */
#define ARM_RAISED_MID 200

/**
 * The low and high arm components are both raised.
 */
#define ARM_RAISED_HIGH 201

/**
 * The low and high arm components are both being raised.
 */
#define ARM_RAISING 202

#define MOTOR_COUNT 10

// Array to hold requested speed for the motors
int motorRequests[MOTOR_COUNT];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[MOTOR_COUNT];

task handleMotorSlew()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
    {
        motorRequests[motorIndex] = 0;
        motorSlew[motorIndex] = 10;
    }

    // run task until stopped
    while (true)
    {
        // run loop for every motor
        for (motorIndex = 0; motorIndex < MOTOR_COUNT; motorIndex++)
        {
            // So we don't keep accessing the internal storage
            motorTmp = motor[motorIndex];

            // Do we need to change the motor value ?
            if (motorTmp != motorRequests[motorIndex])
            {
                // increasing motor value
                if (motorRequests[motorIndex] > motorTmp)
                {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if (motorTmp > motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // decreasing motor value
                if (motorRequests[motorIndex] < motorTmp)
                {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if (motorTmp < motorRequests[motorIndex])
                        motorTmp = motorRequests[motorIndex];
                }

                // finally set motor
                motor[motorIndex] = motorTmp;
            }
        }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec(15);
    }
}

void init()
{
    SensorValue[leftEncoder] = 0;
    SensorValue[rightEncoder] = 0;
}

void driveStraightDistance(int tenthsOfIn, int masterPower)
{
    int tickGoal = (42 * tenthsOfIn) / 10;

    //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
    int totalTicks = 0;

    //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
    //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
    //veering off course at the start of the function.
    int slavePower = masterPower - 5;

    int error = 0;

    int kp = 5;

    SensorValue[leftEncoder] = 0;
    SensorValue[rightEncoder] = 0;

    //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
    while (abs(totalTicks) < tickGoal)
    {
        //Proportional algorithm to keep the robot going straight.
        motor[leftWheels] = masterPower;
        motor[rightWheels] = slavePower;

        error = SensorValue[leftEncoder] - SensorValue[rightEncoder];

        slavePower += error / kp;

        SensorValue[leftEncoder] = 0;
        SensorValue[rightEncoder] = 0;

        wait1Msec(100);

        //Add this iteration's encoder values to totalTicks.
        totalTicks += SensorValue[leftEncoder];
    }
    motor[leftWheels] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
    motor[rightWheels] = 0;
}

void driveDistance(int distance)
{
    driveStraightDistance(distance, MAX_SPEED);
}

/**
 * Performs a point turn by rotating both motors the same distance but in opposite directions.
 * Negative values for degress indicate counter-clockwise turns.
 */
void pointTurn(int degrees)
{
}

/**
 * Performs a pivot turn by locking one wheel in place and rotating the other one.
 * Negative values for degress indicate counter-clockwise turns.
 */
void pivotTurn(int degrees)
{
}

/**
 * Rotates the left motor by the specified amount.
 */
void moveLeftMotor(int amount)
{
    motorRequests[leftWheels] = amount;
}

/**
 * Rotates the right motor by the specified amount.
 */
void moveRightMotor(int amount)
{
    motorRequests[rightWheels] = amount;
}

/**
 * Handles joystick movement to control lateral movement.
 */
task handleDriving()
{
    while (true)
    {
        int leftJoystick = vexRT[Ch3];
        int rightJoystick = vexRT[Ch2];
        moveLeftMotor(leftJoystick);
        moveRightMotor(rightJoystick);
        wait1Msec(25);
    }
}

void raiseLowerArm()
{
    // bool triggered = false;
    // while (!triggered)
    // {
    motor[armLowLeft] = MAX_SPEED;
    motor[armLowRight] = MAX_SPEED;
    wait1Msec(5000);
    // triggered = SensorValue[upperLimitSwitch] == 1;
    // }
}

void raiseUpperArm()
{
    // bool triggered = false;
    // while (!triggered)
    // {
    motor[armHighLeft] = MAX_SPEED;
    motor[armHighRight] = MAX_SPEED;
    wait1Msec(5000);
    //     triggered = SensorValue[upperLimitSwitch] == 1;
    // }
}

void lowerLowerArm()
{
    bool triggered = false;
    while (!triggered)
    {
        motor[armLowLeft] = -MAX_SPEED;
        motor[armLowRight] = -MAX_SPEED;
        triggered = SensorValue[bottomUpperLimitSwitch] == 1;
    }
}

void lowerUpperArm()
{
    bool triggered = false;
    while (!triggered)
    {
        motor[armHighLeft] = -MAX_SPEED;
        motor[armHighRight] = -MAX_SPEED;
        triggered = SensorValue[bottomLimitSwitch] == 1;
    }
}

task raiseCap()
{
    raiseLowerArm();
    raiseUpperArm();
}

task raiseWinch()
{
    motor[winch] = MAX_SPEED;
    wait1Msec(25);
}

task lowerWinch()
{
    motor[winch] = -MAX_SPEED;
    wait1Msec(25);
}

task lowerArm()
{
    lowerLowerArm();
    lowerUpperArm();
}

/**
 * Triggers the claws to open
 */
task grabCap()
{
    motorRequests[claw] = MAX_SPEED;
    wait1Msec(2000);
}

/**
 * Triggers the claws to close
 */
task releaseCap()
{
    motorRequests[claw] = -MAX_SPEED;
    wait1Msec(2000);
}

/**
 * Handles button inputs to control robot peripherals like raising and lowering
 * the arm and launching balls.
 */
task handlePeripherals()
{
    int armState = ARM_LOWERED;
    while (true)
    {
        if (vexRT[Btn5U] == 1)
        {
            motorRequests[armLowLeft] = 0;
            motorRequests[armLowRight] = 0;
            wait1Msec(250);
            motorRequests[armLowLeft] = MAX_SPEED;
            motorRequests[armLowRight] = MAX_SPEED;
            wait1Msec(250);
        }
        else if (vexRT[Btn5D] == 1)
        {
            motorRequests[armLowLeft] = 0;
            motorRequests[armLowRight] = 0;
            wait1Msec(250);
            motorRequests[armLowLeft] = -MAX_SPEED;
            motorRequests[armLowRight] = -MAX_SPEED;
            wait1Msec(250);
        }
        if (vexRT[Btn6U] == 1)
        {
            motorRequests[armHighLeft] = 0;
            motorRequests[armHighRight] = 0;
            wait1Msec(250);
            motorRequests[armHighLeft] = MAX_SPEED;
            motorRequests[armHighRight] = MAX_SPEED;
            wait1Msec(250);
        } else if (vexRT[Btn6D] == 1)
        {
            motorRequests[armHighLeft] = 0;
            motorRequests[armHighRight] = 0;
            wait1Msec(250);
            motorRequests[armHighLeft] = -MAX_SPEED;
            motorRequests[armHighRight] = -MAX_SPEED;
            wait1Msec(250);
        }

        if (vexRT[Btn8R] == 1)
        {
            motorRequests[claw] = MAX_SPEED;
            wait1Msec(250);
        }
        else if (vexRT[Btn8D] == 1)
        {
            motorRequests[claw] = -MAX_SPEED;
            wait1Msec(250);
        }

        if (vexRT[Btn8L] == 1)
        {
            motorRequests[winch] = -MAX_SPEED;
            wait1Msec(250);
        }
        else if (vexRT[Btn8U] == 1)
        {
            motorRequests[winch] = MAX_SPEED;
            wait1Msec(250);
        }

        if (vexRT[Btn7L] == 1)
        {
            // Kill winch
            motorRequests[winch] = 0;
        }

        if (vexRT[Btn7D] == 1)
        {
            // Kill arm lifting
            motorRequests[armLowLeft] = 0;
            motorRequests[armLowRight] = 0;
            motorRequests[armHighLeft] = 0;
            motorRequests[armHighRight] = 0;
        }

        if (vexRT[Btn7U] == 1) {
            motorRequests[port9] = MAX_SPEED;
            wait1Msec(250);
        } else if (vexRT[Btn7D] == 1) {
            motorRequests[port9] = 0;
            wait1Msec(250);
        }
    }
}

/**
 * Runs initialization activites before competition start.
 */
void pre_auton()
{
    init();
}

task autonomous()
{
    driveStraightDistance(10, MAX_SPEED);
}

task userControl()
{
    startTask(handleMotorSlew);
    startTask(handleDriving);
    startTask(handlePeripherals);
    while (true)
    {
        wait1Msec(100);
    }
}

task main()
{
    startTask(userControl);
    while (true);
}
