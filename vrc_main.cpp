#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1, leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2, rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1, leftBumper, sensorTouch)
#pragma config(Sensor, dgtl2, rightBumper, sensorTouch)
#pragma config(Sensor, dgtl3, armBaseEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5, armClawEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7, bottomLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl8, bottomUpperLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl9, topLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl10, upperLimitSwitch, sensorTouch)
#pragma config(Sensor, I2C_1, leftEncoder, sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Sensor, I2C_2, rightEncoder, sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Motor, port1, leftWheels, tmotorVex269_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor, port2, armLowLeft, tmotorServoStandard, openLoop)
#pragma config(Motor, port3, armLowRight, tmotorServoStandard, openLoop)
#pragma config(Motor, port4, armHighLeft, tmotorServoStandard, openLoop)
#pragma config(Motor, port5, armHighRight, tmotorServoStandard, openLoop)
#pragma config(Motor, port6, lifter, tmotorServoStandard, openLoop)
#pragma config(Motor, port7, lifterAssist, tmotorServoStandard, openLoop)
#pragma config(Motor, port8, launcher, tmotorServoStandard, openLoop)
#pragma config(Motor, port9, launcherLift, tmotorServoStandard, openLoop)
#pragma config(Motor, port10, rightWheels, tmotorVex269_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "robotc.h"

#define abs(X) ((X < 0) ? -1 * X : X)

#define ARM_RAISE_TICK_GOAL 100

#define MAX_SPEED 127

// enum Direction
// {
//     FORWARD,
//     BACKWARD,
//     LEFT,
//     RIGHT,
// };

/**
 * Both arm components (low and high) are completely lowered.
 */
#define ARM_LOWERED 100

/**
 * The low arm component is being lowered, but the high isn't.
 */
#define ARM_LOWERING_LOW 101

/**
 * The high arm component is being lowered, but the low isn't.
 */
#define ARM_LOWERING_HIGH 102

/**
 * The low arm component is raised, but the high one isn't.
 */
#define ARM_RAISED_MID 200

/**
 * The low and high arm components are both raised.
 */
#define ARM_RAISED_HIGH 201

/**
 * The low and high arm components are both being raised.
 */
#define ARM_RAISING 202

void init()
{
    SensorValue[leftEncoder] = 0;
    SensorValue[rightEncoder] = 0;
}

void driveStraightDistance(int tenthsOfIn, int masterPower)
{
    int tickGoal = (42 * tenthsOfIn) / 10;

    //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
    int totalTicks = 0;

    //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
    //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
    //veering off course at the start of the function.
    int slavePower = masterPower - 5;

    int error = 0;

    int kp = 5;

    SensorValue[leftEncoder] = 0;
    SensorValue[rightEncoder] = 0;

    //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
    while (abs(totalTicks) < tickGoal)
    {
        //Proportional algorithm to keep the robot going straight.
        motor[leftWheels] = masterPower;
        motor[rightWheels] = slavePower;

        error = SensorValue[leftEncoder] - SensorValue[rightEncoder];

        slavePower += error / kp;

        SensorValue[leftEncoder] = 0;
        SensorValue[rightEncoder] = 0;

        wait1Msec(100);

        //Add this iteration's encoder values to totalTicks.
        totalTicks += SensorValue[leftEncoder];
    }
    motor[leftWheels] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
    motor[rightWheels] = 0;
}

void driveDistance(int distance)
{
}

/**
 * Performs a point turn by rotating both motors the same distance but in opposite directions.
 * Negative values for degress indicate counter-clockwise turns.
 */
void pointTurn(int degrees)
{
}

/**
 * Performs a pivot turn by locking one wheel in place and rotating the other one.
 * Negative values for degress indicate counter-clockwise turns.
 */
void pivotTurn(int degrees)
{
}

/**
 * Rotates the left motor by the specified amount.
 */
void moveLeftMotor(int amount)
{
    motor[leftWheels] = amount;
}

/**
 * Rotates the right motor by the specified amount.
 */
void moveRightMotor(int amount)
{
    motor[rightWheels] = amount;
}

/**
 * Handles joystick movement to control lateral movement.
 */
task handleDriving()
{
    while (true)
    {
        int leftJoystick = vexRT[Ch3];
        int rightJoystick = vexRT[Ch2];
        moveLeftMotor(leftJoystick);
        moveRightMotor(rightJoystick);
    }
}

void raiseLowerArm()
{
    // bool triggered = false;
    // while (!triggered)
    // {
        motor[armLowLeft] = MAX_SPEED;
        motor[armLowRight] = MAX_SPEED;
        wait1Msec(5000);
        // triggered = SensorValue[upperLimitSwitch] == 1;
    // }
}

void raiseUpperArm()
{
    // bool triggered = false;
    // while (!triggered)
    // {
        motor[armHighLeft] = MAX_SPEED;
        motor[armHighRight] = MAX_SPEED;
        wait1Msec(5000);
    //     triggered = SensorValue[upperLimitSwitch] == 1;
    // }
}

void lowerLowerArm()
{
    bool triggered = false;
    while (!triggered)
    {
        motor[armLowLeft] = -MAX_SPEED;
        motor[armLowRight] = -MAX_SPEED;
        triggered = SensorValue[bottomUpperLimitSwitch] == 1;
    }
}

void lowerUpperArm()
{
    bool triggered = false;
    while (!triggered)
    {
        motor[armHighLeft] = -MAX_SPEED;
        motor[armHighRight] = -MAX_SPEED;
        triggered = SensorValue[bottomLimitSwitch] == 1;
    }
}

task raiseCap()
{
    raiseLowerArm();
    raiseUpperArm();
}

task lowerArm()
{
    lowerLowerArm();
    lowerUpperArm();
}

/**
 * Handles button inputs to control robot peripherals like raising and lowering
 * the arm and launching balls.
 */
task handlePeripherals()
{
    int armState = ARM_LOWERED;
    while (true)
    {
        // Group the arm functions
        if (vexRT[Btn5U] == 1)
        {
            startTask(raiseCap);
            switch (armState)
            {
            case ARM_LOWERED:
                armState = ARM_RAISED_MID;
                break;
            default:
            case ARM_RAISED_MID:
                armState = ARM_RAISED_MID;
            }
        }
        else if (vexRT[Btn5D] == 1)
        {
            startTask(lowerArm);
            switch (armState)
            {
            case ARM_RAISED_MID:
                armState = ARM_LOWERED;
                break;
            default:
            case ARM_RAISED_HIGH:
                armState = ARM_RAISED_MID;
            }
        }

        // Special buttons
        if (vexRT[Btn7U] == 1)
        {
            // Abort arm raise, lower arm
            stopTask(raiseCap);
            startTask(lowerArm);
        }
        else if (vexRT[Btn7D] == 1)
        {
            // Abort arm lower, raise arm
            stopTask(lowerArm);
            startTask(raiseCap);
        }
    }
}

/**
 * Runs initialization activites before competition start.
 */
void pre_auton()
{
    init();
}

task autonomous()
{
    // TODO: Fill me in
}

task userControl()
{
    // TODO: Replace with main code
}

task main()
{
    // TODO: Transition to competition model
    init();
    startTask(handleDriving);
    startTask(handlePeripherals);
}
