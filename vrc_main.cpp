#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl1,  leftBumper,     sensorTouch)
#pragma config(Sensor, dgtl2,  rightBumper,    sensorTouch)
#pragma config(Sensor, dgtl3,  armBaseEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  armClawEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftWheels,    tmotorVex269_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           armBase,       tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           extender,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           elbow,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          rightWheels,   tmotorVex269_HBridge, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "robotc.h"

#define abs(X) ((X < 0) ? -1 * X : X)

#define ARM_RAISE_TICK_GOAL 100

enum Direction {
    FORWARD,
    BACKWARD,
    LEFT,
    RIGHT,
};

void init()
{
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void driveStraightDistance(int tenthsOfIn, int masterPower)
{
 int tickGoal = (42 * tenthsOfIn) / 10;

 //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
 int totalTicks = 0;

 //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
 //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
 //veering off course at the start of the function.
 int slavePower = masterPower - 5;

 int error = 0;

 int kp = 5;

 SensorValue[leftEncoder] = 0;
 SensorValue[rightEncoder] = 0;

 //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
 while(abs(totalTicks) < tickGoal)
 {
   //Proportional algorithm to keep the robot going straight.
   motor[leftWheels] = masterPower;
   motor[rightWheels] = slavePower;

   error = SensorValue[leftEncoder] - SensorValue[rightEncoder];

   slavePower += error / kp;

   SensorValue[leftEncoder] = 0;
   SensorValue[rightEncoder] = 0;

   wait1Msec(100);

   //Add this iteration's encoder values to totalTicks.
   totalTicks += SensorValue[leftEncoder];
 }
 motor[leftWheels] = 0; // Stop the loop once the encoders have counted up the correct number of encoder ticks.
 motor[rightWheels] = 0;
}


void driveDistance(int distance) {
}

/**
* Performs a point turn by rotating both motors the same distance but in opposite directions.
* Negative values for degress indicate counter-clockwise turns.
*/
void pointTurn(int degrees)


}

/**
* Performs a pivot turn by locking one wheel in place and rotating the other one.
* Negative values for degress indicate counter-clockwise turns.
*/
void pivotTurn(int degrees)
{
}

task resetArm()
{

}

task grabCap()
{
    // Ensure arm is lowered
    // 
}

task flipCap()
{

}

task raiseCap()
{
    while (motor[armBase] < ARM_RAISE_TICK_GOAL)
    {

    }
}

task launchBallLow()
{

}

task lauchBallHigh()
{

}

task doAutonomous()
{

}

task userControl()
{

}

task main()
{
    init();
    boolean frontBumperTriggered = false;
    if (frontBumperTriggered)
    {
        startTask(raiseCap);

    }
}
